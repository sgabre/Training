
.syntax unified
.cpu cortex-m4
.fpu softvfp
.thumb

.global g_pfnVectors
.global Default_Handler

/* start address for the initialization values of the .data section.
defined in linker script */
.word _sidata
/* start address for the .data section. defined in linker script */
.word _sdata
/* end address for the .data section. defined in linker script */
.word _edata
/* start address for the .bss section. defined in linker script */
.word _sbss
/* end address for the .bss section. defined in linker script */
.word _ebss

/**
 * @brief  This is the code that gets called when the processor first
 *          starts execution following a reset event. Only the absolutely
 *          necessary set is performed, after which the application
 *          supplied main() routine is called.
 * @param  None
 * @retval : None
*/

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
  mov   sp, r0          /* set stack pointer */

/* Call the clock system initialization function.*/
  bl  SystemInit

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
  ldr r1, =_edata
  ldr r2, =_sidata
  movs r3, #0
  b LoopCopyDataInit

CopyDataInit:
  ldr r4, [r2, r3]
  str r4, [r0, r3]
  adds r3, r3, #4

LoopCopyDataInit:
  adds r4, r0, r3
  cmp r4, r1
  bcc CopyDataInit

/* Zero fill the bss segment. */
  ldr r2, =_sbss
  ldr r4, =_ebss
  movs r3, #0
  b LoopFillZerobss

FillZerobss:
  str  r3, [r2]
  adds r2, r2, #4

LoopFillZerobss:
  cmp r2, r4
  bcc FillZerobss

/* Call static constructors */
  bl __libc_init_array
/* Call the application's entry point.*/
  bl main
  bl _ExitTest
LoopForever:
    b LoopForever

  .size Reset_Handler, .-Reset_Handler

/**
 * @brief  This is the code that gets called when the processor receives an
 *         unexpected interrupt.  This simply enters an infinite loop, preserving
 *         the system state for examination by a debugger.
 *
 * @param  None
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
  .size Default_Handler, .-Default_Handler

/******************************************************************************
*
* The STM32WLE5xx vector table.  Note that the proper constructs
* must be placed on this to ensure that it ends up at physical address
* 0x0000.0000.
*
******************************************************************************/
  .section .isr_vector,"a",%progbits
  .type g_pfnVectors, %object
  .size g_pfnVectors, .-g_pfnVectors

g_pfnVectors:
  .word _estack
  .word Reset_Handler
  .word NMI_Handler
  .word HardFault_Handler
  .word	MemManage_Handler
  .word	BusFault_Handler
  .word	UsageFault_Handler
  .word	0
  .word	0
  .word	0
  .word	0
  .word	SVC_Handler
  .word	DebugMon_Handler
  .word	0
  .word	PendSV_Handler
  .word	SysTick_Handler
  .word	WWDG_IRQHandler                      			/* Window Watchdog interrupt                          */
  .word	PVD_PVM_IRQHandler                   			/* PVD and PVM interrupt through EXTI                 */
  .word	TAMP_STAMP_LSECSS_SSRU_IRQHandler    			/* RTC Tamper, RTC TimeStamp, LSECSS and RTC SSRU int.*/
  .word	RTC_WKUP_IRQHandler                  			/* RTC wakeup interrupt through EXTI[19]              */
  .word	FLASH_IRQHandler                     			/* Flash memory global interrupt and Flash memory ECC */
  .word	RCC_IRQHandler                       			/* RCC global interrupt                               */
  .word	EXTI0_IRQHandler                     			/* EXTI line 0 interrupt                              */
  .word	EXTI1_IRQHandler                     			/* EXTI line 1 interrupt                              */
  .word	EXTI2_IRQHandler                     			/* EXTI line 2 interrupt                              */
  .word	EXTI3_IRQHandler                     			/* EXTI line 3 interrupt                              */
  .word	EXTI4_IRQHandler                     			/* EXTI line 4 interrupt                              */
  .word	DMA1_Channel1_IRQHandler             			/* DMA1 channel 1 interrupt                           */
  .word	DMA1_Channel2_IRQHandler             			/* DMA1 channel 2 interrupt                           */
  .word	DMA1_Channel3_IRQHandler             			/* DMA1 channel 3 interrupt                           */
  .word	DMA1_Channel4_IRQHandler             			/* DMA1 channel 4 interrupt                           */
  .word	DMA1_Channel5_IRQHandler             			/* DMA1 channel 5 interrupt                           */
  .word	DMA1_Channel6_IRQHandler             			/* DMA1 channel 6 interrupt                           */
  .word	DMA1_Channel7_IRQHandler             			/* DMA1 channel 7 interrupt                           */
  .word	ADC_IRQHandler                       			/* ADC interrupt                                      */
  .word	DAC_IRQHandler                       			/* DAC interrupt                                      */
  .word	0                                    			/* Reserved                                           */
  .word	COMP_IRQHandler                      			/* COMP1 and COMP2 interrupt through EXTI             */
  .word	EXTI9_5_IRQHandler                   			/* EXTI line 9_5 interrupt                            */
  .word	TIM1_BRK_IRQHandler                  			/* Timer 1 break interrupt                            */
  .word	TIM1_UP_IRQHandler                   			/* Timer 1 Update                                     */
  .word	TIM1_TRG_COM_IRQHandler              			/* Timer 1 trigger and communication                  */
  .word	TIM1_CC_IRQHandler                   			/* Timer 1 capture compare interrupt                  */
  .word	TIM2_IRQHandler                      			/* TIM2 global interrupt                              */
  .word	TIM16_IRQHandler                     			/* Timer 16 global interrupt                          */
  .word	TIM17_IRQHandler                     			/* Timer 17 global interrupt                          */
  .word	I2C1_EV_IRQHandler                   			/* I2C1 event interrupt                               */
  .word	I2C1_ER_IRQHandler                   			/* I2C1 event interrupt                               */
  .word	I2C2_EV_IRQHandler                   			/* I2C2 error interrupt                               */
  .word	I2C2_ER_IRQHandler                   			/* I2C2 error interrupt                               */
  .word	SPI1_IRQHandler                      			/* SPI1 global interrupt                              */
  .word	SPI2_IRQHandler                      			/* SPI2 global interrupt                              */
  .word	USART1_IRQHandler                    			/* USART1 global interrupt                            */
  .word	USART2_IRQHandler                    			/* USART2 global interrupt                            */
  .word	LPUART1_IRQHandler                   			/* LPUART1 global interrupt                           */
  .word	LPTIM1_IRQHandler                    			/* LPtimer 1 global interrupt                         */
  .word	LPTIM2_IRQHandler                    			/* LPtimer 2 global interrupt                         */
  .word	EXTI15_10_IRQHandler                 			/* EXTI line 15_10] interrupt through EXTI            */
  .word	RTC_Alarm_IRQHandler                 			/* RTC Alarms A & B interrupt                         */
  .word	LPTIM3_IRQHandler                    			/* LPtimer 3 global interrupt                         */
  .word	SUBGHZSPI_IRQHandler                 			/* SUBGHZSPI global interrupt                         */
  .word	0                                    			/* Reserved                                           */
  .word	0                                    			/* Reserved                                           */
  .word	HSEM_IRQHandler                      			/* Semaphore interrupt 0 to CPU1                      */
  .word	I2C3_EV_IRQHandler                   			/* I2C3 event interrupt                               */
  .word	I2C3_ER_IRQHandler                   			/* I2C3 error interrupt                               */
  .word	SUBGHZ_Radio_IRQHandler              			/* Radio IRQs RFBUSY interrupt through EXTI           */
  .word	AES_IRQHandler                       			/* AES global interrupt                               */
  .word	RNG_IRQHandler                       			/* RNG interrupt                                      */
  .word	PKA_IRQHandler                       			/* PKA interrupt                                      */
  .word	DMA2_Channel1_IRQHandler             			/* DMA2 channel 1 interrupt                           */
  .word	DMA2_Channel2_IRQHandler             			/* DMA2 channel 2 interrupt                           */
  .word	DMA2_Channel3_IRQHandler             			/* DMA2 channel 3 interrupt                           */
  .word	DMA2_Channel4_IRQHandler             			/* DMA2 channel 4 interrupt                           */
  .word	DMA2_Channel5_IRQHandler             			/* DMA2 channel 5 interrupt                           */
  .word	DMA2_Channel6_IRQHandler             			/* DMA2 channel 6 interrupt                           */
  .word	DMA2_Channel7_IRQHandler             			/* DMA2 channel 7 interrupt                           */
  .word	DMAMUX1_OVR_IRQHandler               			/* DMAMUX overrun interrupt                           */

/*******************************************************************************
*
* Provide weak aliases for each Exception handler to the Default_Handler.
* As they are weak aliases, any function with the same name will override
* this definition.
*
*******************************************************************************/

	.weak	NMI_Handler
	.thumb_set NMI_Handler,Default_Handler

	.weak	HardFault_Handler
	.thumb_set HardFault_Handler,Default_Handler

	.weak	MemManage_Handler
	.thumb_set MemManage_Handler,Default_Handler

	.weak	BusFault_Handler
	.thumb_set BusFault_Handler,Default_Handler

	.weak	UsageFault_Handler
	.thumb_set UsageFault_Handler,Default_Handler

	.weak	SVC_Handler
	.thumb_set SVC_Handler,Default_Handler

	.weak	DebugMon_Handler
	.thumb_set DebugMon_Handler,Default_Handler

	.weak	PendSV_Handler
	.thumb_set PendSV_Handler,Default_Handler

	.weak	SysTick_Handler
	.thumb_set SysTick_Handler,Default_Handler

	.weak	WWDG_IRQHandler
	.thumb_set WWDG_IRQHandler,Default_Handler

	.weak	PVD_PVM_IRQHandler
	.thumb_set PVD_PVM_IRQHandler,Default_Handler

	.weak	TAMP_STAMP_LSECSS_SSRU_IRQHandler
	.thumb_set TAMP_STAMP_LSECSS_SSRU_IRQHandler,Default_Handler

	.weak	RTC_WKUP_IRQHandler
	.thumb_set RTC_WKUP_IRQHandler,Default_Handler

	.weak	FLASH_IRQHandler
	.thumb_set FLASH_IRQHandler,Default_Handler

	.weak	RCC_IRQHandler
	.thumb_set RCC_IRQHandler,Default_Handler

	.weak	EXTI0_IRQHandler
	.thumb_set EXTI0_IRQHandler,Default_Handler

	.weak	EXTI1_IRQHandler
	.thumb_set EXTI1_IRQHandler,Default_Handler

	.weak	EXTI2_IRQHandler
	.thumb_set EXTI2_IRQHandler,Default_Handler

	.weak	EXTI3_IRQHandler
	.thumb_set EXTI3_IRQHandler,Default_Handler

	.weak	EXTI4_IRQHandler
	.thumb_set EXTI4_IRQHandler,Default_Handler

	.weak	DMA1_Channel1_IRQHandler
	.thumb_set DMA1_Channel1_IRQHandler,Default_Handler

	.weak	DMA1_Channel2_IRQHandler
	.thumb_set DMA1_Channel2_IRQHandler,Default_Handler

	.weak	DMA1_Channel3_IRQHandler
	.thumb_set DMA1_Channel3_IRQHandler,Default_Handler

	.weak	DMA1_Channel4_IRQHandler
	.thumb_set DMA1_Channel4_IRQHandler,Default_Handler

	.weak	DMA1_Channel5_IRQHandler
	.thumb_set DMA1_Channel5_IRQHandler,Default_Handler

	.weak	DMA1_Channel6_IRQHandler
	.thumb_set DMA1_Channel6_IRQHandler,Default_Handler

	.weak	DMA1_Channel7_IRQHandler
	.thumb_set DMA1_Channel7_IRQHandler,Default_Handler

	.weak	ADC_IRQHandler
	.thumb_set ADC_IRQHandler,Default_Handler

	.weak	DAC_IRQHandler
	.thumb_set DAC_IRQHandler,Default_Handler

	.weak	COMP_IRQHandler
	.thumb_set COMP_IRQHandler,Default_Handler

	.weak	EXTI9_5_IRQHandler
	.thumb_set EXTI9_5_IRQHandler,Default_Handler

	.weak	TIM1_BRK_IRQHandler
	.thumb_set TIM1_BRK_IRQHandler,Default_Handler

	.weak	TIM1_UP_IRQHandler
	.thumb_set TIM1_UP_IRQHandler,Default_Handler

	.weak	TIM1_TRG_COM_IRQHandler
	.thumb_set TIM1_TRG_COM_IRQHandler,Default_Handler

	.weak	TIM1_CC_IRQHandler
	.thumb_set TIM1_CC_IRQHandler,Default_Handler

	.weak	TIM2_IRQHandler
	.thumb_set TIM2_IRQHandler,Default_Handler

	.weak	TIM16_IRQHandler
	.thumb_set TIM16_IRQHandler,Default_Handler

	.weak	TIM17_IRQHandler
	.thumb_set TIM17_IRQHandler,Default_Handler

	.weak	I2C1_EV_IRQHandler
	.thumb_set I2C1_EV_IRQHandler,Default_Handler

	.weak	I2C1_ER_IRQHandler
	.thumb_set I2C1_ER_IRQHandler,Default_Handler

	.weak	I2C2_EV_IRQHandler
	.thumb_set I2C2_EV_IRQHandler,Default_Handler

	.weak	I2C2_ER_IRQHandler
	.thumb_set I2C2_ER_IRQHandler,Default_Handler

	.weak	SPI1_IRQHandler
	.thumb_set SPI1_IRQHandler,Default_Handler

	.weak	SPI2_IRQHandler
	.thumb_set SPI2_IRQHandler,Default_Handler

	.weak	USART1_IRQHandler
	.thumb_set USART1_IRQHandler,Default_Handler

	.weak	USART2_IRQHandler
	.thumb_set USART2_IRQHandler,Default_Handler

	.weak	LPUART1_IRQHandler
	.thumb_set LPUART1_IRQHandler,Default_Handler

	.weak	LPTIM1_IRQHandler
	.thumb_set LPTIM1_IRQHandler,Default_Handler

	.weak	LPTIM2_IRQHandler
	.thumb_set LPTIM2_IRQHandler,Default_Handler

	.weak	EXTI15_10_IRQHandler
	.thumb_set EXTI15_10_IRQHandler,Default_Handler

	.weak	RTC_Alarm_IRQHandler
	.thumb_set RTC_Alarm_IRQHandler,Default_Handler

	.weak	LPTIM3_IRQHandler
	.thumb_set LPTIM3_IRQHandler,Default_Handler

	.weak	SUBGHZSPI_IRQHandler
	.thumb_set SUBGHZSPI_IRQHandler,Default_Handler

	.weak	HSEM_IRQHandler
	.thumb_set HSEM_IRQHandler,Default_Handler

	.weak	I2C3_EV_IRQHandler
	.thumb_set I2C3_EV_IRQHandler,Default_Handler

	.weak	I2C3_ER_IRQHandler
	.thumb_set I2C3_ER_IRQHandler,Default_Handler

	.weak	SUBGHZ_Radio_IRQHandler
	.thumb_set SUBGHZ_Radio_IRQHandler,Default_Handler

	.weak	AES_IRQHandler
	.thumb_set AES_IRQHandler,Default_Handler

	.weak	RNG_IRQHandler
	.thumb_set RNG_IRQHandler,Default_Handler

	.weak	PKA_IRQHandler
	.thumb_set PKA_IRQHandler,Default_Handler

	.weak	DMA2_Channel1_IRQHandler
	.thumb_set DMA2_Channel1_IRQHandler,Default_Handler

	.weak	DMA2_Channel2_IRQHandler
	.thumb_set DMA2_Channel2_IRQHandler,Default_Handler

	.weak	DMA2_Channel3_IRQHandler
	.thumb_set DMA2_Channel3_IRQHandler,Default_Handler

	.weak	DMA2_Channel4_IRQHandler
	.thumb_set DMA2_Channel4_IRQHandler,Default_Handler

	.weak	DMA2_Channel5_IRQHandler
	.thumb_set DMA2_Channel5_IRQHandler,Default_Handler

	.weak	DMA2_Channel6_IRQHandler
	.thumb_set DMA2_Channel6_IRQHandler,Default_Handler

	.weak	DMA2_Channel7_IRQHandler
	.thumb_set DMA2_Channel7_IRQHandler,Default_Handler

	.weak	DMAMUX1_OVR_IRQHandler
	.thumb_set DMAMUX1_OVR_IRQHandler,Default_Handler

	.weak	SystemInit

#/tests/TestFramework/Startup/STM32WLE5/CMakeLists.txt
add_library(StartupObjects OBJECT
    startup.s
    syscalls.c
    sysmem.c
    system.c
)

target_include_directories(StartupObjects PUBLIC
    ${CMAKE_CURRENT_SOURCE_DIR}
)

syscalls.c

/* Includes */
#include <sys/stat.h>
#include <stdlib.h>
#include <errno.h>
#include <stdio.h>
#include <signal.h>
#include <time.h>
#include <sys/time.h>
#include <sys/times.h>


/* Variables */
extern int __io_putchar(int ch) __attribute__((weak));
extern int __io_getchar(void) __attribute__((weak));


char *__env[1] = { 0 };
char **environ = __env;


/* Functions */
void initialise_monitor_handles()
{
}

int _getpid(void)
{
  return 1;
}

int _kill(int pid, int sig)
{
  (void)pid;
  (void)sig;
  errno = EINVAL;
  return -1;
}

void _ExitTest (int status)
{
  (status) ? printf("*STOP*1\n") : printf("*STOP*0\n");
}

void _exit (int status)
{
  //(status) ? printf("*STOP*1\n") : printf("*STOP*0\n");
  _kill(status, -1);
  //__asm__("bkpt #0");
  while (1) {}    /* Make sure we hang here */
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
  {
    *ptr++ = __io_getchar();
  }

  return len;
}

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
  {
    __io_putchar(*ptr++);
  }
  return len;
}

int _close(int file)
{
  (void)file;
  return -1;
}


int _fstat(int file, struct stat *st)
{
  (void)file;
  st->st_mode = S_IFCHR;
  return 0;
}

int _isatty(int file)
{
  (void)file;
  return 1;
}

int _lseek(int file, int ptr, int dir)
{
  (void)file;
  (void)ptr;
  (void)dir;
  return 0;
}

int _open(char *path, int flags, ...)
{
  (void)path;
  (void)flags;
  /* Pretend like we always fail */
  return -1;
}

int _wait(int *status)
{
  (void)status;
  errno = ECHILD;
  return -1;
}

int _unlink(char *name)
{
  (void)name;
  errno = ENOENT;
  return -1;
}

int _times(struct tms *buf)
{
  (void)buf;
  return -1;
}

int _stat(char *file, struct stat *st)
{
  (void)file;
  st->st_mode = S_IFCHR;
  return 0;
}

int _link(char *old, char *new)
{
  (void)old;
  (void)new;
  errno = EMLINK;
  return -1;
}

int _fork(void)
{
  errno = EAGAIN;
  return -1;
}

int _execve(char *name, char **argv, char **env)
{
  (void)name;
  (void)argv;
  (void)env;
  errno = ENOMEM;
  return -1;
}

#/Tests/ComponentTesting/Dummy/CMakeLists.txt

# Find all unit test source files ending with _Suite.c
file(GLOB SUITE_SOURCES *_Suite.c)

# Loop over each test source and create a runner
foreach(SUITE_FILE ${SUITE_SOURCES})
    
    # Get the file name without extension and path
    get_filename_component(SUITE_NAME ${SUITE_FILE} NAME_WE)
    message(STATUS "Create ${SUITE_NAME} build configuration")
    # Create one executable per test suite
    if(CMAKE_CROSSCOMPILING)
        add_executable(${SUITE_NAME} ${SUITE_FILE} $<TARGET_OBJECTS:StartupObjects>)
    else()
        add_executable(${SUITE_NAME} ${SUITE_FILE}) 
    endif()

    # Link with your test dependencies
    target_link_libraries(${SUITE_NAME} PRIVATE Dummy Unity)

    if(CMAKE_CROSSCOMPILING AND SEMIHOSTING STREQUAL "RTT")
        target_link_libraries(${SUITE_NAME} PRIVATE -Wl,--whole-archive Semihosting_RTT -Wl,--no-whole-archive)
    endif()

    if(CMAKE_CROSSCOMPILING)
        target_link_options(${SUITE_NAME} PRIVATE -T${CMAKE_SOURCE_DIR}/Tests/TestFramework/Startup/${MCU_TYPE}/${MCU_TYPE}.ld)
    endif()

    if(CMAKE_CROSSCOMPILING)
    set_target_properties(${SUITE_NAME} PROPERTIES
        OUTPUT_NAME ${SUITE_NAME}.elf
        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin/tests
    )
    else()
        set_target_properties(${SUITE_NAME} PROPERTIES
        OUTPUT_NAME ${SUITE_NAME}
        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin/tests
    )
    endif()
    # Register test with CTest
    if(CMAKE_CROSSCOMPILING)
        #set_tests_properties(${SUITE_NAME} PROPERTIES TIMEOUT 300)
        set (JRUN_CTEST_COMMAND "JRun" --verbose --device STM32WLE5CC --rtt -if SWD)
        add_test( NAME ${SUITE_NAME} COMMAND JRun  --verbose --device STM32WLE5CC --rtt -if SWD $<TARGET_FILE:${SUITE_NAME}>)
        set_property(TEST ${SUITE_NAME} PROPERTY RUN_SERIAL TRUE)
    else()
        add_test(NAME ${SUITE_NAME} COMMAND ${SUITE_NAME})
    endif()

    # Optional: install it under bin/tests
    install(TARGETS ${SUITE_NAME} RUNTIME DESTINATION bin/tests)
endforeach()

# ./Tests/CMakeLists.txt
#project(Tests C)

#enable_testing()

# Include Unity CMake file
include(${CMAKE_SOURCE_DIR}/.cmake/Unity.cmake)
include(${CMAKE_SOURCE_DIR}/.cmake/CException.cmake)
include(${CMAKE_SOURCE_DIR}/.cmake/CMock.cmake)

# Generate Mocks (Only for Component Testing, we will see for the ComponentIntegrationTesting later)
# Disable for the momeent
#if(TEST_LEVEL STREQUAL "ALL" OR TEST_LEVEL STREQUAL "ComponentTesting")
#    include(${CMAKE_SOURCE_DIR}/.cmake/cmocks.cmake)
#    generate_mocks()
#endif()

#if(TEST_LEVEL STREQUAL "ALL" OR TEST_LEVEL STREQUAL "ComponentTesting" OR TEST_LEVEL STREQUAL "ComponentIntegrationTesting")
#    add_subdirectory(Mocks)
#endif()

if(TEST_LEVEL STREQUAL "ALL" OR TEST_LEVEL STREQUAL "ComponentTesting")
	message(STATUS "Component Testing Selected")	
    add_subdirectory(TestFramework)    
    add_subdirectory(ComponentTesting)
endif()

if(TEST_LEVEL STREQUAL "ALL" OR TEST_LEVEL STREQUAL "ComponentIntegrationTesting")
    add_subdirectory(ComponentIntegrationTesting)
endif()

---
:cmock:
  :mock_path: @MOCK_PATH@
  :mock_prefix: mock_
  :plugins:
    - :array
    - :callback
    - :cexception
    - :expect
    - :expect_any_args
    - :ignore
    - :ignore_arg
    # - :ignore_stateless
    - :return_thru_ptr

# Noteworthy info: weak attribute are not supported by MinGw.... (so can't use :weak: option)

function(generate_mocks)

    set(MODULES_DIR ${CMAKE_SOURCE_DIR}/Firmware/Modules)
    set(MOCKS_DIR   ${CMAKE_SOURCE_DIR}/Tests/Mocks)
    set(YAML_TEMPLATE ${CMAKE_SOURCE_DIR}/.cmake/cmock.yml.in)

    file(GLOB MODULE_HEADERS
        RELATIVE ${MODULES_DIR}
        ${MODULES_DIR}/*/*.h
    )

    set(ALL_MOCK_HEADERS)

    foreach(HEADER ${MODULE_HEADERS})

        get_filename_component(MODULE_NAME ${HEADER} DIRECTORY)
        string(REPLACE "\\" "/" MODULE_NAME ${MODULE_NAME})

        set(MODULE_MOCK_DIR ${MOCKS_DIR}/${MODULE_NAME})
        set(MOCK_HEADER ${MODULE_MOCK_DIR}/mock_${MODULE_NAME}.h)

        list(APPEND ALL_MOCK_HEADERS ${MOCK_HEADER})

        add_custom_command(
            OUTPUT ${MOCK_HEADER}
            COMMAND ${CMAKE_COMMAND} -E make_directory ${MODULE_MOCK_DIR}
            COMMAND ${CMAKE_COMMAND}
                -DMODULE_NAME=${MODULE_NAME}
                -DMODULE_MOCK_DIR=${MODULE_MOCK_DIR}
                -DMODULES_DIR=${MODULES_DIR}
                -DYAML_TEMPLATE=${YAML_TEMPLATE}
                -P ${CMAKE_SOURCE_DIR}/.cmake/create_mock.cmake
            DEPENDS ${MODULES_DIR}/${HEADER}
            COMMENT "Generating mock for ${MODULE_NAME}"
        )

    endforeach()

    add_custom_target(mocks ALL
        DEPENDS ${ALL_MOCK_HEADERS}
    )

endfunction()

configure_file(
    ${YAML_TEMPLATE}
    ${MODULE_MOCK_DIR}/cmock.yml
    @ONLY
)

execute_process(
    COMMAND ruby
        ${CMAKE_SOURCE_DIR}/Tests/TestFramework/CMock/lib/cmock.rb
        -o ${MODULE_MOCK_DIR}/cmock.yml
        ${MODULES_DIR}/${MODULE_NAME}.h
)

#/Tests/Mocks/@MODULE_NAME@/CMakeLists.txt
# Build une library libMock@MODULE_NAME@.a from the source files in this directory.

# Collect mock sources in this directory
file(GLOB MOCK_SOURCES
    ${CMAKE_CURRENT_SOURCE_DIR}/mock_*.c
)

# Safety check
if(NOT MOCK_SOURCES)
    message(FATAL_ERROR "No mock sources found for @MODULE_NAME@")
endif()

# Create static mock library
add_library(Mock@MODULE_NAME@ STATIC ${MOCK_SOURCES})

# Public include directory for tests
target_include_directories(Mock@MODULE_NAME@
    PUBLIC
        ${CMAKE_CURRENT_SOURCE_DIR}
        ${CMAKE_SOURCE_DIR}/Firmware/Modules/@MODULE_NAME@
        ${CMAKE_SOURCE_DIR}/Tests/Unity/src
        ${CMAKE_SOURCE_DIR}/Tests/CException/lib
)

# Link Unity and CException
target_link_libraries(Mock@MODULE_NAME@
    PUBLIC
        Unity
        CMock
        CException
)

# --------------------------------------------------------------------
# arm-none-eabi-gcc.cmake
# Toolchain file for ARM Cortex-M cross-compilation
# --------------------------------------------------------------------

# Enforce this is a cross-compile
set(CMAKE_SYSTEM_NAME Generic)
set(CMAKE_SYSTEM_VERSION 1)
set(CMAKE_SYSTEM_PROCESSOR arm)
set(CMAKE_CROSSCOMPILING TRUE)

# Toolchain prefix
set(TOOLCHAIN_PREFIX arm-none-eabi-)

set(CMAKE_C_COMPILER  "${TOOLCHAIN_PREFIX}gcc")
set(CMAKE_CXX_COMPILER "${TOOLCHAIN_PREFIX}g++")
set(CMAKE_ASM_COMPILER "${CMAKE_C_COMPILER}")
set(CMAKE_LINKER      "${TOOLCHAIN_PREFIX}g++")
set(CMAKE_OBJCOPY     "${TOOLCHAIN_PREFIX}objcopy")
set(CMAKE_SIZE        "${TOOLCHAIN_PREFIX}size")

set(CMAKE_TRY_COMPILE_TARGET_TYPE STATIC_LIBRARY)
set(CMAKE_EXECUTABLE_SUFFIX .elf)


# --------------------------------------------------------------------
# MCU/ABI Configuration
# --------------------------------------------------------------------

# Cortex-M4 default flags (override per MCU if needed)
set(MCU_FLAGS "-mcpu=cortex-m4 -mfloat-abi=soft -mthumb" CACHE STRING "MCU compiler flags")

# Assembler flags
set(ASM_FLAGS "-c -x assembler-with-cpp")

# GCC Compiler flag 
set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${MCU_FLAGS} -std=gnu11 -Wall -Wextra -Wpedantic -ffunction-sections -fdata-sections -fstack-usage")


# Build type optimizations
if(CMAKE_BUILD_TYPE MATCHES Debug)
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -O0 -g3")
endif()
if(CMAKE_BUILD_TYPE MATCHES Release)
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Os -g0")
endif()

# --------------------------------------------------------------------
# Linker flags
# --------------------------------------------------------------------
set(CMAKE_C_LINK_FLAGS "${CMAKE_C_LINK_FLAGS} -Wl,-Map=${CMAKE_PROJECT_NAME}.map")    
set(CMAKE_C_LINK_FLAGS "${CMAKE_C_LINK_FLAGS} -Wl,--gc-sections -static")

# --------------------------------------------------------------------
message(STATUS "MCU_FLAGS: ${MCU_FLAGS}")
message(STATUS "ASM_FLAGS: ${ASM_FLAGS}")
message(STATUS "CMAKE_C_FLAGS: ${CMAKE_C_FLAGS}")
message(STATUS "CMAKE_C_LINK_FLAGS: ${CMAKE_C_LINK_FLAGS}")





